import React, { ReactNode, useLayoutEffect, useRef } from 'react';
import styled, { keyframes, css, useTheme } from 'styled-components';
import { getRippleLayer, getCloudSpritesForMoment, MonetTheme } from '../../theme/monetTheme';
import { SceneComposer } from '../scene/SceneComposer';
import { SceneForegroundProvider } from '../scene/SceneForegroundContext';

const drift = keyframes`
  0% { background-position: 0 0; }
  50% { background-position: 24px 10px; }
  100% { background-position: 0 0; }
`;

const cloudGlide = keyframes`
  0% { transform: translateX(0); }
  100% { transform: translateX(-20%); }
`;

const Surface = styled.div.attrs({ 'data-scene-surface': 'true' })`
  position: relative;
  min-height: 100vh;
  width: 100%;
  padding: clamp(16px, 4vw, 40px);
  overflow-x: hidden;
  overflow-y: auto;
  background-color: ${({ theme }) => theme.colors.backgroundPage};
  background-image: ${({ theme }) =>
    `linear-gradient(180deg, ${theme.scene?.palette.waterLight ?? '#6E8FD1'} 0%, ${theme.scene?.palette.waterMid ?? '#2E4F9A'} 38%, ${theme.scene?.palette.waterDeep ?? '#10224B'} 100%)`};
  image-rendering: pixelated;

  &::before {
    content: '';
    position: absolute;
    inset: 0;
    ${({ theme }) => {
      const isDark = theme.mode === 'dark';
      const warm = `radial-gradient(circle at 55% 30%, rgba(255, 206, 173, 0.35), transparent 55%)`;
      const cool = `radial-gradient(circle at 40% 20%, rgba(160, 197, 255, 0.4), transparent 60%)`;
      return css`
        background-image: ${isDark ? `${cool}, ${warm}` : `${warm}, ${cool}`};
        opacity: ${isDark ? 0.55 : 0.45};
        mix-blend-mode: ${isDark ? 'screen' : 'multiply'};
      `;
    }}
    pointer-events: none;
    z-index: -2;
  }

  &::after {
    content: '';
    position: absolute;
    inset: 0;
    ${({ theme }) => {
      const ripple = getRippleLayer(theme.mode ?? 'light', theme.moment ?? 'morning', theme.intensity ?? 'rich');
      return css`
        background-image: url(${ripple.image});
        background-size: ${ripple.size};
        background-repeat: ${ripple.repeat};
        background-position: ${ripple.position ?? '0 0'};
        opacity: ${ripple.opacity};
      `;
    }}
    mix-blend-mode: soft-light;
    pointer-events: none;
    z-index: -1;
    animation: ${({ theme }) => (theme.motion ? css`${drift} 18s ease-in-out infinite alternate` : 'none')};
  }
`;

const CloudField = styled.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: clamp(200px, 34vh, 420px);
  pointer-events: none;
  z-index: 1;
`;

const CloudStratum = styled.div<{
  $img: string;
  $top: string;
  $speed: number;
  $opacity: number;
  $z: number;
}>`
  position: absolute;
  left: -20vw;
  width: 140vw;
  height: clamp(120px, 24vh, 300);
  top: ${(p) => p.$top};
  background-image: url(${(p) => p.$img});
  background-repeat: repeat-x;
  background-size: auto 200%;
  opacity: ${(p) => p.$opacity};
  animation: ${cloudGlide} ${(p) => p.$speed}s linear infinite;
  z-index: ${(p) => p.$z};
  filter: drop-shadow(0 8px 24px rgba(15, 30, 69, 0.22));
`;

const ContentLayer = styled.div`
  position: relative;
  z-index: 5;
  width: 100%;
  height: 100%;

  & > * {
    position: relative;
    z-index: 1;
  }
`;

type Props = {
  children: ReactNode;
  className?: string;
};

export function PageBackground({ children, className }: Props) {
  const surfaceRef = useRef<HTMLDivElement>(null);
  const theme = useTheme() as MonetTheme;
  const moment = theme.moment ?? 'morning';
  const cloudStack = getCloudSpritesForMoment(moment);

  useLayoutEffect(() => {
    const update = () => {
      const root = surfaceRef.current;
      if (!root) return;
      const rootRect = root.getBoundingClientRect();
      const willowOffsetPx = Math.max(32, rootRect.width * 0.06);
      root.style.setProperty('--willow-offset', `${willowOffsetPx}px`);
      const hero = root.querySelector('[data-hero-readiness="true"]') as HTMLElement | null;
      if (!hero) return;
      const heroRect = hero.getBoundingClientRect();
      const gap = 12; // px gap under hero
      const topPx = Math.max(0, heroRect.bottom - rootRect.top + gap);
      root.style.setProperty('--bridge-top', `${topPx}px`);
      // Expose hero top/right for precise sun placement
      const heroTop = Math.max(0, heroRect.top - rootRect.top);
      const heroRight = Math.max(0, heroRect.right - rootRect.left);
      const heroLeft = Math.max(0, heroRect.left - rootRect.left);
      root.style.setProperty('--hero-top', `${heroTop}px`);
      root.style.setProperty('--hero-right', `${heroRight}px`);
      root.style.setProperty('--hero-left', `${heroLeft}px`);

      const doc = document.documentElement;
      const docStyles = getComputedStyle(doc);
      const bridgeAR = parseFloat(docStyles.getPropertyValue('--bridge-ar') || '6');
      const bridgeRefAR = parseFloat(docStyles.getPropertyValue('--bridge-ref-ar') || '6');
      const arcWidth = Math.max(0, rootRect.width - 2 * willowOffsetPx);
      const arcHeight = arcWidth / Math.max(bridgeAR, 0.1);
      const bridgeBottom = topPx + arcHeight;
      root.style.setProperty('--bridge-band-bottom', `${bridgeBottom}px`);
      const reflectionHeight = arcWidth / Math.max(bridgeRefAR, 6);
      const reflectionBottom = bridgeBottom + reflectionHeight;
      root.style.setProperty('--reflection-band-bottom', `${reflectionBottom}px`);
      root.style.setProperty('--safe-metrics-top', `${reflectionBottom + 24}px`);

      const boatTop = parseFloat(docStyles.getPropertyValue('--boat-lane-top') || '0');
      const boatBottom = parseFloat(docStyles.getPropertyValue('--boat-lane-bottom') || '0');
      if (!Number.isNaN(boatTop) && !Number.isNaN(boatBottom)) {
        root.style.setProperty('--boat-lane-top', `${boatTop}px`);
        root.style.setProperty('--boat-lane-bottom', `${boatBottom}px`);
        root.style.setProperty('--boat-padding', `${Math.max(0, rootRect.bottom - boatTop)}px`);
      } else {
        root.style.setProperty('--boat-padding', '64px');
      }
    };
    update();
    const obs = new ResizeObserver(update);
    if (surfaceRef.current) obs.observe(surfaceRef.current);
    const hero = surfaceRef.current?.querySelector('[data-hero-readiness="true"]') as HTMLElement | null;
    if (hero) obs.observe(hero);
    const onResize = () => update();
    window.addEventListener('resize', onResize);
    return () => {
      window.removeEventListener('resize', onResize);
      obs.disconnect();
    };
  }, []);

  return (
    <Surface className={className} ref={surfaceRef}>
      <CloudField aria-hidden>
        {cloudStack.back.map((img, index) => (
          <CloudStratum
            key={`cloud-back-${index}`}
            $img={img}
            $top={`${index * 4}vh`}
            $speed={80 + index * 20}
            $opacity={0.35 - index * 0.05}
            $z={1}
          />
        ))}
        {cloudStack.mid.map((img, index) => (
          <CloudStratum
            key={`cloud-mid-${index}`}
            $img={img}
            $top={`${8 + index * 5}vh`}
            $speed={50 + index * 12}
            $opacity={0.55 - index * 0.08}
            $z={2}
          />
        ))}
      </CloudField>
      <SceneForegroundProvider>
        <SceneComposer />
        <ContentLayer>{children}</ContentLayer>
      </SceneForegroundProvider>
    </Surface>
  );
}
